package com.darkprograms.mysqldecrypter.gui;

import com.darkprograms.mysqldecrypter.util.MainUtil;
import com.darkprograms.mysqldecrypter.util.UpdateUIUtil;

import javax.swing.*;

/**
 * The Main GUI for the application
 * Design by DeanTheft, coded by TheShadow
 */
public class MainGUI extends javax.swing.JFrame {

    private static MainGUI instance;

    public static MainGUI getInstance() {
        if (instance == null) {
            instance = new MainGUI();
        }
        return instance;
    }

    /**
     * Creates new form MainGUI
     */
    private MainGUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">
    private void initComponents() {

        decrypt = new javax.swing.JButton();
        progress = new javax.swing.JProgressBar();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        encryptedHashes = new javax.swing.JTextArea();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        version = new javax.swing.JLabel();
        threads = new javax.swing.JSpinner();
        jScrollPane2 = new javax.swing.JScrollPane();
        decryptedHashes = new javax.swing.JEditorPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("MySQL Hash Decrypter");

        decrypt.setText("Decrypt");
        decrypt.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                decryptActionPerformed(evt);
            }
        });

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        jLabel1.setText("MySQL Hash Decrypter by TheShadow");

        encryptedHashes.setColumns(20);
        encryptedHashes.setFont(new java.awt.Font("Monospaced", 0, 10)); // NOI18N
        encryptedHashes.setRows(5);
        encryptedHashes.setToolTipText("The encrypted MySQL hashes to decrypt, 1 per line.");
        encryptedHashes.setCursor(new java.awt.Cursor(java.awt.Cursor.TEXT_CURSOR));
        jScrollPane1.setViewportView(encryptedHashes);

        jLabel3.setText("Number of Threads");

        jLabel4.setText("Encrypted Hashes");

        jLabel5.setText("Decrypted Hashes");

        version.setText("Version 1.01");

        threads.setValue(5);

        decryptedHashes.setEditable(false);
        decryptedHashes.setContentType("text/html");
        decryptedHashes.setCursor(new java.awt.Cursor(java.awt.Cursor.TEXT_CURSOR));
        jScrollPane2.setViewportView(decryptedHashes);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                                .addContainerGap()
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                                        .addComponent(progress, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 393, Short.MAX_VALUE)
                                                        .addComponent(decrypt, javax.swing.GroupLayout.DEFAULT_SIZE, 393, Short.MAX_VALUE)
                                                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                                                .addComponent(jLabel1)
                                                                .addGap(98, 98, 98)
                                                                .addComponent(jLabel3))
                                                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                                                .addGap(340, 340, 340)
                                                                .addComponent(threads, javax.swing.GroupLayout.PREFERRED_SIZE, 53, javax.swing.GroupLayout.PREFERRED_SIZE))
                                                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 162, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                                .addGap(18, 18, 18)
                                                                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 213, Short.MAX_VALUE))
                                                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                                                .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                                .addGap(135, 135, 135)
                                                                .addComponent(jLabel5))))
                                        .addGroup(layout.createSequentialGroup()
                                                .addGap(171, 171, 171)
                                                .addComponent(version, javax.swing.GroupLayout.PREFERRED_SIZE, 62, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addContainerGap())
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(layout.createSequentialGroup()
                                                .addGap(10, 10, 10)
                                                .addComponent(jLabel3)
                                                .addGap(6, 6, 6)
                                                .addComponent(threads, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 19, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jLabel5))
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 258, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 258, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(decrypt)
                                .addGap(11, 11, 11)
                                .addComponent(progress, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(version)
                                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>

    /**
     * Instance for MainUtil
     */
    MainUtil mu = MainUtil.getInstance();

    /**
     * Method called when decrypt button is pressed
     *
     * @param evt Event
     */
    private void decryptActionPerformed(java.awt.event.ActionEvent evt) {
        if (mu.getRunningState() == false) {
            decrypt.setEnabled(false);


            if (checkParams() == false) {
                decrypt.setEnabled(true);
                return;
            }
            decryptedHashes.setText("");
            progress.setIndeterminate(true);
            decrypt.setText("Stop");
            String[] encryptedHashesArray = encryptedHashes.getText().split("\n");
            for (int i = 0; i < encryptedHashesArray.length; i++) {
                String hash = encryptedHashesArray[i].trim();
                mu.addEncryptedPassword(hash);
                mu.addStringToStrWriter(hash + ": Waiting...\n");


                if (encryptedHashesArray[i].length() != 16) {
                    mu.addDecryptedPasswordToEncrypted(hash, MainUtil.INVALID_HASH_CODE);
                }
            }
            mu.setThreads(Integer.parseInt(threads.getValue().toString()));

            mu.setRunningState(true);
            mu.startDecrypt();
            new Thread(new UpdateUIUtil()).start();
            decrypt.setEnabled(true);
        } else {
            decrypt.setEnabled(false);
            mu.setRunningState(false);
            mu.clearAll();
            decrypt.setText("Decrypt");
            if (progress.isIndeterminate()) {
                progress.setIndeterminate(false);
                progress.setValue(0);
            }
            decrypt.setEnabled(true);
        }


    }

    /**
     * Method called via UpdateUIUtil to update the UI and display a different number
     * of dots and insert found hashes into the program to the user
     */
    public void updateAllStatus() {
        String[] hashes = mu.getTextFromBuffer().split("\n");
        String dots = null;
        int completed = 0;

        if (mu.getDots() == 1) {
            dots = ".";
        } else if (mu.getDots() == 2) {
            dots = "..";
        } else if (mu.getDots() == 3) {
            dots = "...";
        }
        mu.clearStringWriter();
        mu.addStringToStrWriter("<html><font size=3>\n");
        for (int i = 0; i < hashes.length; i++) {
            if (hashes[i].equals("<html><font size=3>")) {
                continue;
            }
            String[] hashAndStatus = hashes[i].split(":");
            if (mu.getDecryptedPassword(hashAndStatus[0]) == null) {
                if (mu.isHashLocked(hashAndStatus[0])) {
                    mu.addStringToStrWriter(hashAndStatus[0] + ": Decrypting" + dots + "<br>\n");
                } else {
                    mu.addStringToStrWriter(hashAndStatus[0] + ": Waiting" + dots + "<br>\n");
                }

            } else {
                completed++;
                mu.addStringToStrWriter(hashAndStatus[0] + ": " + mu.getDecryptedPassword(hashAndStatus[0]) + "<br>\n");
            }
        }
        mu.addStringToStrWriter("</font></html>");
        decryptedHashes.setText(mu.getTextFromBuffer());
        if (mu.getDots() == 3) {
            mu.setDots(1);
        } else {
            mu.setDots(mu.getDots() + 1);
        }


        int size = mu.getHashesSize();
        double percent = ((double) completed / (double) size) * 100.00;
        int intPercent = (int) percent;

        if (percent != 0) {
            if (progress.isIndeterminate() == true) {
                progress.setIndeterminate(false);
            }
            progress.setValue(intPercent);
        }
    }


    /**
     * Methods checks params from encrypted hashses and threads to check if they are valid
     *
     * @return Returns true if valid, false otherwise
     */
    public boolean checkParams() {
        if (encryptedHashes.getText().isEmpty()) {
            JOptionPane.showMessageDialog(MainGUI.getInstance(), "You must enter input for encrypted hashes field.", "Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        if (Integer.parseInt(threads.getValue().toString()) <= 0) {
            JOptionPane.showMessageDialog(MainGUI.getInstance(), "Number of threads must be greater then 0.", "Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        return true;
    }

    /**
     * Method called on completion to clear UI and other data
     */
    public void complete() {
        decrypt.setEnabled(false);
        mu.setRunningState(false);
        mu.clearAll();
        decrypt.setText("Decrypt");
        if (progress.isIndeterminate()) {
            progress.setIndeterminate(false);
            progress.setValue(0);
        }
        decrypt.setEnabled(true);
    }


    // Variables declaration - do not modify
    private javax.swing.JButton decrypt;
    private javax.swing.JEditorPane decryptedHashes;
    private javax.swing.JTextArea encryptedHashes;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JProgressBar progress;
    private javax.swing.JSpinner threads;
    private javax.swing.JLabel version;
    // End of variables declaration
}
